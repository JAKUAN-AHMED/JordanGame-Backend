
//MediaConvert only deals with encoding and chunk creation.
//CloudFront only delivers the resulting HLS stream to users



import { bookmarkModel, Ibookmark, Story } from "./story.model";
import AppError from "../../errors/AppError";
import { User } from "../user/user.model";
import QueryBuilder from "../../builder/QueryBuilder";
import { v4 as uuidv4 } from 'uuid';
import { uploadSingleFileToS3 } from "../../helpers/S3Service";
import { createMediaConvertJob } from "./stroy.constant";
import { config } from "../../config";


export const storyServices = {
  saveStoryDB: async (data: {
  userId: string,
  caption: string,
  description: string,
  tags: string[],
  type: "image" | "video" | "audio",
  files: Express.Multer.File[],
  expiresAt: Date
}) => {
    const { files, type } = data;

  if (!files || files.length === 0)
    throw new Error("No files provided");

  if ((type === "video" || type === "audio") && files.length > 1)
    throw new Error("Only single video/audio is allowed");

  const mediaUrls: string[] = [];

  for (const file of files) {
    if (type === "image") {
      const url = await uploadSingleFileToS3(file, `story/${type}`);
      mediaUrls.push(url);
    }
    // } else {
    //   // Step1: Upload raw file
    //   const rawUrl = await uploadSingleFileToS3(file, `story/raw`);

    //   // Step2: Convert to HLS
    //   const outputFolder = `story/${type}/${uuidv4()}`;
    //   await createMediaConvertJob(rawUrl, outputFolder);

    //   // Step3: Store manifest URL
    //   mediaUrls.push(`https://${config.aws.bucketName}.s3.${config.aws.region}.amazonaws.com/${outputFolder}/index.m3u8`);
    // }
  }

  const story = await Story.create({ ...data, mediaUrl: mediaUrls });
  return story;
  },
  deleteStroy: async (payload: {
    userId: string,
    id: string
  }) => {
    const { userId, id } = payload;
    if (!await User.isExistUserById(userId)) {
      throw new AppError(404, 'User Not Found')
    }

    await bookmarkModel.findOneAndDelete({
      storyId: id
    })
    return await Story.findOneAndDelete(
      { userId, _id: id },
    )
  },
  getMyStories: async (payload: { userId: string; query: Record<string, any> }) => {
    const { userId, query } = payload;

    const queryWithLimit = { ...query, limit: 1 };
    // check if user exists
    const userExists = await User.isExistUserById(userId);
    if (!userExists) {
      throw new AppError(404, "User Not Found");
    }

    const builder = new QueryBuilder(queryWithLimit, Story as any);

    const stories = await builder
      .filter(["type"])
      .search(["caption"])
      .sort()
      .paginate()
      .execute();

    const meta = await builder.countTotal();

    return {
      meta,
      data: stories,
    };
  },
  updateMyStory: async (payload: {
    userId: string,
    id: string,
    data: Partial<{
      caption: string,
      description: string
    }>
  }) => {
    const { userId, id, data } = payload;
    return await Story.findByIdAndUpdate({
      _id: id,
      userId,
    },
      data
      , {
        new: true,
        runValidators: true
      })
  },
  getLatestStories: async () => {
    return Story.find().sort({ createdAt: -1 }).limit(10);
  },
  libraryData: async (query: Record<string, any>) => {
    const types: ("audio" | "video" | "image")[] = ["audio", "video", "image"];

    const data: Record<string, any> = {};

    for (const type of types) {
      // extract pagination info for this type
      const { page = 1, limit = 10, ...restQuery } = query[type] || {};

      const typeQuery = { ...restQuery, type, page, limit };

      const builder = new QueryBuilder(typeQuery, Story as any);

      const results = await builder
        .filter(["type"])
        .search(["caption"])
        .sort()
        .paginate()
        .execute();

      const meta = await builder.countTotal();

      data[type] = {
        meta,
        results,
      };
    }

    return { data };
  },


  //bookmark related services
  bookmarkStory: async (payload: Ibookmark) => {
    const { userId, storyId } = payload;
    if (!userId || !storyId) {
      throw new AppError(404, 'Required field missing')
    }
    const isStoryExist = await Story.isStoryExistByUserId(storyId as any, userId as any);
    if (!isStoryExist) {
      throw new AppError(404, 'For this Id Story Doesnt Exist');
    }

    const isBookMarkExist = await bookmarkModel.isBookMarkExistUserId(storyId as any, userId as any);
    if (isBookMarkExist) {
      throw new AppError(404, 'For this UserId and StoryId Already Exist');
    }
    return await bookmarkModel.create(payload);
  },
  getAllMyBookmark: async (userId: string, query: any) => {
    const builder = new QueryBuilder(query, bookmarkModel as any);
    const bookmarks = await builder
      .filter(["userId"])
      .include([
        { path: 'userId' },
        { path: 'storyId' },
      ])
      .paginate()
      .execute();

    const meta = await builder.countTotal();

    return {
      meta,
      data: bookmarks
    }
  },
  getSingleMyBookmark: async (payload: {
    userId: string, bookmarkId: string
  }) => {

    const { userId, bookmarkId } = payload;
    return await bookmarkModel.findOne({
      _id: bookmarkId,
      userId
    })
      .populate('userId')
      .populate('storyId')
  },
  deleteBookmark: async (payload: {
    userId: string, bookmarkId: string
  }) => {
    const { userId, bookmarkId } = payload;
    const isStoryExist = await Story.findById(bookmarkId);
    if (!isStoryExist) {
      throw new AppError(404, 'Already Deleted');
    }
    return await bookmarkModel.findOneAndDelete({
      _id: bookmarkId,
      userId
    })
  }


};


2️⃣ CloudFront

Where it’s used: As a Content Delivery Network (CDN) in front of your S3 output bucket.

Purpose: Serves HLS chunks and manifest files to users fast and globally.

Benefits:

Low latency: Users around the world can stream chunks quickly.

Reduces load on S3 bucket.

Provides HTTPS URLs for secure streaming.

Supports caching, which improves performance.

✅ Key point:

MediaConvert only deals with encoding and chunk creation.

CloudFront only delivers the resulting HLS stream to users.

If you want, I can update your Node.js story upload service to automatically:

Upload video/audio to S3

Trigger MediaConvert job with your role

Return the CloudFront URL for frontend streaming


//CloudFront

1️⃣ Setup CloudFront

Go to AWS CloudFront → Create Distribution → Web.

Origin Domain: Your S3 bucket where MediaConvert outputs the HLS chunks (index.m3u8 + .ts files).

Default Behavior: Leave default.

Cache Policy: Standard or customize for streaming.

Enable HTTPS.

Finish creation. You’ll get a CloudFront domain, e.g.:



//AWS IAM
